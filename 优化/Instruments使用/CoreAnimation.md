### CoreAnimation : 评估图形性能，屏幕渲染

用于调试`离屏渲染`，`绘图`，`动画`，`图层混合`等`GPU耗时`操作

![](../images/CoreAnimation.png)



现在的版本中，CoreAnimation只能看到FPS，其他的需要在Xcode中查看



**真机**

![](../images/CoreAnimation02.png)



详细用法可查看【界面流程优化】里的【离屏渲染】-> 【屏幕渲染的检测.md】



**模拟器**

![](../界面流畅优化/images/off-screen01.png)





- ##### Color Blended Layer 图层混合

```
首先我们要明白像素的概念，屏幕上每一个点都是一个像素，像素有R、G、B三种颜色构成(有时候还带有alpha值)。如果某一块区域上覆盖了多个layer,最后的显示效果受到这些layer的共同影响。举个例子，上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blending)需要消耗一定的GPU资源，因为实际上可能不止只有两层。如果只想显示最上层的蓝色，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。
```

标识区域使用多种混合图层：

![](../界面流畅优化/images/ColorBlendedLayer.png)



红色：混合图层

绿色：没有使用混合

调优：减少红色区域

			1. 设置opaque属性为true【代码初始化默认值为true,xib或者nib默认值为false】

      			2.  给View设置一个不透明的颜色，

```
这个选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮（也就是多个半透明图层的叠加）。由于重绘的原因，混合对GPU性能会有影响，同时也是滑动或者动画帧率下降的罪魁祸首之一。

GPU每一帧可以绘制的像素有一个最大限制（就是所谓的fill rate），这个情况下可以轻易地绘制整个屏幕的所有像素。但是如果由于重叠图层的关系需要不停地重绘同一区域的话，掉帧就可能发生了。

GPU会放弃绘制那些完全被其他图层遮挡的像素，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素（即混合）消耗的资源也是相当客观的。所以为了加速处理进程，不到必须时刻不要使用透明图层。任何情况下，你应该这样做：

给视图的backgroundColor属性设置一个固定的，不透明的颜色
设置opaque属性为YES
如果用到了图像，尽量避免透明除非非常必要。如果图像要显示在一个固定的背景颜色或是固定的背景图之前，你没必要相对前景移动，你只需要预填充背景图片就可以避免运行时混色了。
如果是文本的话，一个白色背景的UILabel（或者其他颜色）会比透明背景要更高效。

Color Blended Layers”正是用于检测哪里发生了图层混合，并用红色标记出来。因此我们需要尽可能减少看到的红色区域。一旦发现应该想法设法消除它。
```



- ##### Color Hits green add Misses Red 光栅化（缓存layer）

检测layer是否使用shouldRasterize, 为true开启光栅化（默认），光栅化会将layer预先渲染为位图bitmap,然后缓存，从而提高性能。

注意：光栅化的核心在于缓存的思想。

红色： 光栅化

绿色：未光栅化 

```
调优：适用内容不变的layer,  不适合tableView，会造成多余离屏渲染降低性能（原因：系统给光栅化限制了内存，如果超过就会离屏渲染）。

这是因为layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。这就是为什么停留一会儿再滑动就会看到红色。当我们使用得当时，光栅化可以提供很大的性能优势，但是一定要避免作用在内容不断变动的图层上，否则它缓存方面的好处就会消失，而且会让性能变的更糟。
```



- ##### Color Copied Images 图片格式检测与复制

Shows images that are copied by Core Animation in blue苹果官方注释被拷贝给CPU进行转化的图片显示为绿色。那么这句话怎么理解呢？如果GPU不支持当前图片的颜色格式，那么就会将图片交给CPU预先进行格式转化，并且这张图片标记为蓝色。那么GPU支持什么格式呢？苹果的GPU只解析32bit的颜色格式，如果使用Color Copied Images去调试发现是蓝色。

CPU主要处理两件事：
（1）把图片从PNG或JPEG等格式中解压出来，得到像素数据
（2）如果GPU不支持这种颜色各式，CPU需要进行格式转换
比如应用中有一些从网络下载的图片，而GPU恰好不支持这个格式，这就需要CPU预先进行格式转化。

![](../界面流畅优化/images/ColorCopiedImages.png)



知识扩展：32bit指的是图片颜色深度，用“位”来表示，用来表示显示颜色数量，例如一个图片支持256种颜色，那么就需要256个不同的值来表示不同的颜色，也就是从0到255，二进制表示就是从00000000到11111111，一共需要8位二进制数，所以颜色深度是8。通常32bit色彩中使用三个8bit分别表示R红G绿B蓝,还有一个8bit常用来表示透明度（Alpha）





- ##### Color misaliged Images 图片尺寸匹配

目标像素与源像素不对齐的图像， 比如图片大小和UIImageView大小不一致。

**颜色标识**：洋红色（图片没有像素对齐）， 黄色（图片缩放）

![](../界面流畅优化/images/ColormisaligedImages.png)



调优：要尽可能保证无论是本地图片还是从网络或取得图片的大小，都与其frame保持一致。



- ##### Color Offscreen_Rendered Yellow 离屏渲染

离屏渲染就是GPU新开一个缓冲区进行渲染操作，渲染结束后再切换当前屏幕渲染，非常消耗性能，实际开发应该避免。

**标记颜色**：黄色(发生离屏渲染)

![](../界面流畅优化/images/ColorOffscreen_RenderedYellow.png)



**优化**：尽量避免黄色，避免造成离屏渲染方法的调用。



- ##### Color Compositing Fast-Path Blue 快速路径

标记由硬件绘制的路径，显示蓝色，越多越好。 可以直接对OpenGL绘制的图像高亮。

```
离屏渲染的最后一步是把此前的多个路径组合起来。如果这个组合过程能由CPU完成，就会大量减少GPU的工作。这种技术在绘制地图中可能用到。
```

**颜色标记**：蓝色

这个选项会对任何直接使用OpenGL绘制的图层进行高亮。如果仅仅使用UIKit或者Core Animation的API，那么不会有任何效果。如果使用GLKView或者CAEAGLLayer，那如果不显示蓝色块的话就意味着你正在强制CPU渲染额外的纹理，而不是绘制到屏幕。



- ##### Flash updated Regions 重绘区域

这个选项会对重绘的内容高亮成黄色,重绘就是指使用Core Graphics绘制，绘制会损耗一定的性能，因此重绘区域应该越小越好。

**颜色标识**：黄色



- ##### Color Immediately 颜色刷新频率

当执行颜色刷新的时候移除10ms的延迟，因为可能在特定情况下你不需要这些延迟，所以使用此选项加快颜色刷新的频率。不过一般这个调试选项我们是用不到的。