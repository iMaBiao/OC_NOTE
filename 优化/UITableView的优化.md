#### UITableView的优化1

https://www.jianshu.com/p/5182234b2e1c

造成tableView卡顿的原因,从硬件上来说无非就两个,一个是CPU原因,一个是GPU原因.

如果CPU核数较多,并发处理问题的能力也就越强,处理大量计算也不在话下;

如果GPU显存够大,渲染能力足够强,处理复杂图形界面也就得心应手

 最基本的就是减少cell的自定义类型,重用cell,每次只绘制屏幕显示cell的数量,其它cell从缓存中取.

#### 1. 减轻CPU负荷

我们知道CPU的主要负责快速调度任务,大量计算工作,所以在tableView快速滚动的过程中让CPU的计算量降低是优化应该考虑的方向.下面总结了三个方面来尽可能的降低CPU计算:

##### 1.1提前计算好cell的高度,缓存在相应的数据源模型中

##### 1.2 尽可能的降低storyboard,xib等使用度

之前看到一些大家分享的相关资料,通过Interface知道xib或者storyboard本身就是一个xml文件,添加删除控件必然中间多了一个encode/decode过程,增加了cpu的计算量.并且 还要避免臃肿的 XIB 文件,因为XIB文件在主线程中进行加载布局.当用到一些自定义View或者XIB文件时,XIB的加载会把所有内容加载进来,如果XIB里面的一些控件并不会用到,这就可能造成一些资源的消耗浪费.

##### 1.3 滑动过程中尽量减少重新布局

自动布局就是给控件添加约束,约束最终还是转换成frame.所以,在满足业务需求情况下,如果图层层次较为复杂,要尽量减少自动布局约束,转为手动计算布局,大量的约束重叠也会增加cpu的计算量  

        有时会在获取到数据源时,每次都重新布局控件,这个也是一个重要开销,也是接下来需要优化的方向

#### 2. 不要阻塞主线程

**UIKit的工作基本上都是在主线程上进行,界面绘制,用户输入响应等等.当所有的代码逻辑都放在主线程时,某些耗时任务可能会卡住主线程造成程序无法响应,流畅度降低等问题;在主线程中绘制大量界面图层,网络I/O,磁盘I/O等都可以造成界面卡顿现象.**

```
下面我们通过Xcode自带的调试工具Instruments来看看项目界面的流畅度,及其一些建议,Instruments给我提供了各种各样的调试查看工具,下面简单介绍一下:
        1)Blank: 创建一个空的模板,可以从Library库中添加其他模板.
        2)Activity Monitor: 监控进程级别的CPU,内存,磁盘,网络使用情况,可以得到你的应用程序在手机运行时总共占用的内存大小.
        3)Allocations: 跟踪过程的匿名虚拟内存和堆的对象提供类名和可选保留/释放历史,可以检测每一个堆对象的分配内存情况.
        4)Cocoa Layout : 观察NSLayoutConstraint对象的改变,帮助我们判断什么时间什么地点的constraint是否合理.观察约束变化,找出布局代码的问题所在.
        5)Core Animation: 这个模块显示程序显卡性能以及CPU使用情况,查看界面流畅度.
        6)CoreData: 这个模块跟踪Core Data文件系统活动.
        7)Counters : 收集使用时间或基于事件的抽样方法的性能监控计数器(PMC)事件.
        8)Energy Log: 耗电量监控.
        9)File Activity: 检测文件创建,移动,变化,删除等.
        10)Leak: 一般的措施内存使用情况，检查泄漏的内存，并提供了所有活动的分配和泄漏模块的类对象分配统计信息以及内存地址历史记录.
        11)Metal System Trace: Metal API是apple 2014年在ios平台上推出的高效底层的3D图形API,它通过减少驱动层的API调用CPU的消耗提高渲染效率.
        12)Network: 用链接工具分析你的程序如何使用TCP/IP和UDP/IP链接.
        13)SceneKit: 3D性能状况分析.
        14)System Trace: 系统跟踪,通过显示当前被调度线程提供综合的系统表现,显示从用户到系统的转换代码通过两个系统调用或内存操作.
        15)System Usage: 这个模板记录关于文件读写,sockets,I/O系统活动,输入输出.
        16)Time Profiler(时间探查): 执行对系统的CPU上运行的进程低负载时间为基础采样.
        17)Zombies: 测量一般的内存使用,专注于检测过度释放的野指针对象,也提供对象分配统计，以及主动分配的内存地址历史.
```

