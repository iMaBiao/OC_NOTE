### 快速排序

https://blog.csdn.net/morewindows/article/details/6684558

快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。

该方法的基本思想是：

1．先从数列中取出一个数作为基准数。

2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。

3．再对左右区间重复第二步，直到各区间只有一个数。

```
//快速排序  
void quick_sort(int s[], int l, int r) {
    if (l < r) {
        //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1
        int i = l, j = r, x = s[l];
        while (i < j) {
            while(i < j && s[j] >= x) {// 从右向左找第一个小于x的数
                j--;
            }
            if(i < j) {
                s[i] = s[j];
            }

            while(i < j && s[i] < x) {// 从左向右找第一个大于等于x的数
                i++;
            }
            if(i < j) {
                s[j] = s[i];
            }
        }
        s[i] = x;
        quick_sort(s, l, i - 1); // 递归调用
        quick_sort(s, i + 1, r);
    }
}
```



---

### MJ

#### 选择排序

>##### 执行流程：
>
>1、从序列中找出最大的那个元素，然后与最末尾的元素交换位置
>
>（执行完一轮后，最末尾的那个元素就是最大的元素）
>
>2、忽略第一步中曾经找到的最大元素，重复执行步骤1



>选择排序的交换次数要远远小于冒泡排序，平均性能优于冒泡排序
>
>平均时间复杂度：O(n²)，空间复杂度：O(1)，
>
>属于不稳定排序 	//如： 7  5  10  10   2  4  2



```java
static void selectionSort(Interget[] array){
	for(int end = array.length-1; end>0; end--){
    int maxIndex = 0;
    for(int begin = 1; begin<= end; begin++){
      if(array[maxIndex] <= array[begin]){
        maxIndex = begin;
      }
    }
    int temp = array[maxIndex];
    array[maxIndex] = array[end];
    array[end] = temp;
    
  }
}
```

